from flask import Flask, request, render_template, redirect, url_for, jsonify
import pandas as pd
import json
import pickle
import joblib
import numpy as np
import logging
from tensorflow.keras.models import load_model
from combined_model import CombinedModel
from stable_baselines3 import DQN
from stable_baselines3.common.vec_env import DummyVecEnv
from RL_Env import MalwareClassificationEnv
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split

app = Flask(__name__)

# Load dataset and prepare training data for RL environment
df = pd.read_csv('reduced_combined_df.csv')
X = df.drop(columns=['class'])
y = df['class']
label_encoder = LabelEncoder()
y_encoded = label_encoder.fit_transform(y)
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, stratify=y_encoded, test_size=0.15, random_state=42)

# Load the models
with open('ML_RL_model.pkl', 'rb') as file:
    voting_clf = pickle.load(file)

with open('rf_model.pkl', 'rb') as file:
    rf_model = pickle.load(file)

nn_model = load_model('nn_model.keras')
env = MalwareClassificationEnv(X_train, y_train)
env = DummyVecEnv([lambda: env])
rl_model = DQN.load('rl_model.pkl')
combined_model = CombinedModel(voting_clf=voting_clf, rl_model=rl_model, env=env)

# Define the features and malware types
features = [
    'getcommandlinea', 'getstartupinfoa', 'lockresource', 'getprocaddress',
    'getcurrentthreadid', 'virtualallocex', 'getsystemdirectorya', 'getversionexa',
    'getmodulehandlea', 'gettickcount', 'gettickcount.1', 'loadresource', 
    'loadlibrarya', 'freelibrary', 'findclose', 'readfile', 'createprocessa',
    'getcurrentprocess', 'createthread', 'raiseexception', 'createremotethread',
    'createfilea', 'getwindowsdirectorya', 'createmutexa', 'isdebuggerpresent',
    'callnexthookex', 'setwindowshookexa'
]
malware_types = [
    'AdWare', 'Backdoor', 'Benign', 'Bootkit', 'Email-Worm', 'Generic Malware', 'Hoax', 'Packed',
    'RAT', 'Ransomware', 'Trojan', 'Trojan-Downloader', 'Trojan-Dropper', 'Trojan-FakeAV',
    'Trojan-PSW', 'Trojan-Spy', 'Virus', 'Worm'
]

def process_json(json_data):
    # Initialize a dictionary to store the presence of each feature
    extracted_features = {feature: 0 for feature in features}

    # Check if each feature is present in the data
    for feature in features:
        if feature in str(json_data).lower():  # Convert JSON to string and check
            extracted_features[feature] = 1

    # Return only the feature values (0s and 1s) as a numpy array
    return np.array(list(extracted_features.values())).reshape(1, -1)

@app.route('/')
def index():
    return render_template('index2.html')

@app.route('/predict', methods=['POST'])
def predict():
    try:
        if 'file' not in request.files:
            return redirect(request.url)

        file = request.files['file']

        if file.filename == '':
            return redirect(request.url)

        if file:
            # Read the JSON file
            json_data = json.load(file)
            
            # Process the JSON data to extract features as an array of 0s and 1s
            x_test = process_json(json_data)
            
            # Make predictions using the trained models
            rf_prediction = rf_model.predict(x_test)[0]
            nn_prediction = np.argmax(nn_model.predict(x_test))
            RL_prediction = combined_model.predict(x_test)[0]

            # Log the prediction results
            app.logger.info(f'RF Prediction: {rf_prediction}')
            app.logger.info(f'NN Prediction: {nn_prediction}')
            app.logger.info(f'RL Prediction: {RL_prediction}')

            # Map the predictions to malware types
            rf_prediction = malware_types[rf_prediction]
            nn_prediction = malware_types[nn_prediction]
            RL_prediction = malware_types[RL_prediction]

            # Return the prediction results
            return render_template('result2.html', rf_prediction=rf_prediction, nn_prediction=nn_prediction, RL_prediction=RL_prediction)

    except Exception as e:
        # Log the detailed error message
        app.logger.error(f'Error occurred during prediction: {str(e)}')
        return jsonify({'error': 'An error occurred while making the prediction.'})

if __name__ == '__main__':
    # Set up logging
    logging.basicConfig(level=logging.INFO)
    app.run(debug=True)
